/// \file Объявление классов для работы с XML, XPath, DTD

#ifndef _SYSTEMPROM_XML_H
#define _SYSTEMPROM_XML_H

// В настройках проекта необходимо прописать следующие пути поиска заголовочных файлов:
// ../../common/libxml2/include
// ../../common/iconv/include

#include <QString>
#include <QVariant>

#include "libxml/xmlreader.h"
#include "libxml/xpath.h"

#ifdef SPM_XML_EXPORTS
	#if defined(WIN32) || defined(_WIN32)
		#define SPM_XML_API __declspec(dllexport)
	#else
		#define SPM_XML_API 
	#endif
#else
	#if defined(WIN32) || defined(_WIN32)
		#define SPM_XML_API __declspec(dllimport)
	#else
		#define SPM_XML_API 
	#endif
#endif

#define SPM_XML_CHILD			1	///< Новый узел создается в поддереве контекстного узла
#define SPM_XML_NEXT_SIBLING	2	///< Новый узел создается за контекстным узлом
#define SPM_XML_PREV_SIBLING	3	///< Новый узел создается перед контекстным узлом

/// Класс-оболочка для работы с XML документом
class SPM_XML_API CSpmXml
{
public:
	/// Конструктор по умолчанию.
	/// Требуется дальнейшая инициализация при помощи функций \ref New, \ref Load или \ref Attach
	CSpmXml(				
				bool bAutoDestroy = true	/// < Признак автоматического освобождения всех ресурсов, связанных с документом. Ручное освобождение ресурсов осуществляется при помощи функции \ref Destroy
			);

	/// Конструктор для привязки к существующему документу.
	CSpmXml(
				xmlDocPtr pDoc,				/// < Указатель на привязываемый документ
				bool bAutoDestroy = false,	/// < Признак автоматического освобождения всех ресурсов, связанных с документом. Ручное освобождение ресурсов осуществляется при помощи функции \ref Destroy
				bool bModified = false		/// < Признак наличия изменений документа с момента создания или последнего сохранения
			);

	/// Конструктор для привязки к существующему документу по заданному узлу.
	/// Указанный узел считаеся текущим узлом при выполнении контекстных операций.
	CSpmXml	(
				xmlNodePtr pNode,			/// < Указатель на узел привязываемого документ
				bool bAutoDestroy = false,	/// < Признак автоматического освобождения всех ресурсов, связанных с документом. Ручное освобождение ресурсов осуществляется при помощи функции \ref Destroy
				bool bModified = false		/// < Признак наличия изменений документа с момента создания или последнего сохранения
			);

	/// Деструктор
	virtual ~CSpmXml();

// Операторы
public:
	/// Оператор для прямого доступа к объекту документа
	xmlDocPtr operator ->() {return m_pXMLDoc;};

	/// Оператор преобразования типа к классу документа
	operator xmlDocPtr() {return m_pXMLDoc;};

	/// Оператор преобразования типа к классу узла документа
	operator xmlNodePtr() {return m_pCurNode;};

// Функции
public:
	/// Привязка к существующему документу.
	/// \return Признак успешности выполнения привязки.
	bool Attach	(
					xmlDocPtr pDoc,				/// < Указатель на привязываемый документ
					bool bAutoDestroy = false,	/// < Признак автоматического освобождения всех ресурсов, связанных с документом. Ручное освобождение ресурсов осуществляется при помощи функции \ref Destroy
					bool bModified = false		/// < Признак наличия изменений документа с момента создания или последнего сохранения
				);

	/// Привязка к существующему документу по заданному узлу.
	/// Указанный узел считаеся текущим узлом при выполнении контекстных операций.
	/// \return Признак успешности выполнения привязки.
	bool Attach	(
					xmlNodePtr pNode,			/// < Указатель на узел привязываемого документ
					bool bAutoDestroy = false,	/// < Признак автоматического освобождения всех ресурсов, связанных с документом. Ручное освобождение ресурсов осуществляется при помощи функции \ref Destroy
					bool bModified = false		/// < Признак наличия изменений документа с момента создания или последнего сохранения
				);

	/// Отсоединение от документа
	void Detach();

	/// Освобождение всех ресурсов, связанных с документом
	void Destroy();

	/// Создание нового документа
	/// \return Признак успешности создания документа.
	bool New(
				const QString& strRootNode, /// < Наименование корневого узла документа
				const QString& strDTDFile = "" /// < Полное имя файла с DTD диаграммой создаваемого документа
			);

	/// Открытие существующего документа
	/// \return Признак успешности открытия документа.
	bool Load	(
					const QString& strFileName,			 ///< Полное имя файла окрываемого документа
					bool bDTDValidation = true			///< Признак необходимости проверки корректности структуры 
				);

	/// Открытие существующего документа из строки
	/// \return Признак успешности открытия документа.
	bool LoadXML(
					const QString& strXML, /// < Текстовое содержимое окрываемого документа
					bool bDTDValidation = true	/// < Признак необходимости проверки корректности структуры 
				);

	/// Сохранение документа в файл
	/// \return Признак успешности сохранения документа.
	bool Save	(
					const QString& strFileName /// < Полное имя файла для сохранения документа
				);

	/// Сохранение документа в строку
	/// \return Признак успешности сохранения документа.
	bool SaveXML(
					QString& strXML, /// < Строка для сохранения документа
					const QString& strCodec = "ASCII" /// < Кодировка выходной строки
				);

	/// Проверка наличия изменений.
	/// \return Признак наличия изменений документа с момента создания или последнего сохранения
	bool IsModified	();

	/// Установка признака наличия изменений
	void SetModified(
						bool bModified = true /// < Признак наличия изменений документа с момента создания или последнего сохранения
					);

	/// Создание нового узла.
	/// После успешного создания узла, он становится текущим для документа.
	/// \return Указатель на созданный узел. Если возвращается 0, то при создании возникла ошибка
	xmlNodePtr AddNode	(
							const QString& strNodeName,		///< Наименование создаваемого узла
							xmlNodePtr pContext = 0,		///< Указатель на контекстный узел. Если передается 0, контекстным узлом считается текущий узел.
							char nContext = SPM_XML_CHILD,	///< Положение нового узла относительно контекстного
							const QString& strContent = ""	///< Содержиоме узла
						);

	/// Добавление существующего узла, созданного штатными средствами libxml или при помощи функции \ref Clone
	/// \return Признак успешного выполнения операции
	bool AddNode	(
						xmlNodePtr pNode,				///< Указатель на присоединяемый узел
						xmlNodePtr pContext = 0,		///< Указатель на контекстный узел. Если передается 0, контекстным узлом считается текущий узел.
						char nContext = SPM_XML_CHILD	///< Положение нового узла относительно контекстного
					);

	/// Перенос узла, созданного штатными средствами libxml или при помощи функции \ref Clone
	/// \return Признак успешного выполнения операции
	bool MoveNode	(
						xmlNodePtr pNode,				///< Указатель на перемещаемый узел
						xmlNodePtr pContext = 0,		///< Указатель на контекстный узел. Если передается 0, контекстным узлом считается текущий узел.
						char nContext = SPM_XML_CHILD	///< Положение нового узла относительно контекстного
					);

	/// Удаление узла
	/// \return Признак успешного удаления узла.
	bool DeleteNode	(
						xmlNodePtr pNode = 0 ///< Удаляемый узел. Если передан 0, то удаляется текущий узел.
					);

	/// Удаление списка узлов, удовлетворяющих XPath запросу
	/// \return Признак успешного удаления узлов.
	bool DeleteNodes(
						const QString& strXPathQuery,		///< XPath запрос, используемый для получения списка удаляемых узлов
						xmlNodePtr pParent = 0				///< Узел, в поддереве которого осуществляется поиск. Если передается 0, то поиск осуществляется в поддереве текущего узла
					);

	/// Получение абсолютного пути узла
	/// \return Абсолютный путь узла.
	QString GetPath	(
						xmlNodePtr pNode = 0		///< Узел, чье имя необходимо вернуть. Если передан 0, то возвращается имя текущего узла
					);

	/// Получение имени узла
	/// \return Имя узла.
	QString GetName	(
						xmlNodePtr pNode = 0		///< Узел, чье имя необходимо вернуть. Если передан 0, то возвращается имя текущего узла
					);

	/// Получение значения узла
	/// \return Значение узла. Если при получении значения возникли ошибки, тип возвращаемого значения устанавливается в QVariant::Invalid
	QVariant GetValue	(
							xmlNodePtr pNode = 0		///< Узел, чье значение необходимо вернуть. Если передан 0, то значение берется у текущего узла
						);

	/// Установка значения узла
	/// \return Признак успешного выполнения операции.
	bool SetValue	(
						const QVariant& vtValue,	///< Устанавливаемое значение
						xmlNodePtr pNode = 0		///< Узел, чье значение необходимо установить. Если передан 0, то устанавливается значение текущего узла
					);

	/// Получение значения атрибута
	/// \return Значение атрибута. Если при получении атрибута возникли ошибки, тип возвращаемого значения устанавливается в QVariant::Invalid
	QVariant GetAttr(
					const QString& strAttrName, ///< Название атрибута
					xmlNodePtr pNode = 0		///< Узел, содержащий атрибут. Если передан 0, то атрибут берется у текущего элемента
				);

	/// Установка значения атрибута
	/// \return Признак успешного выполнения операции.
	bool SetAttr(
					const QString& strAttrName, ///< Название атрибута
					const QVariant& vtAttrVal,	///< Устанавливаемое значение
					xmlNodePtr pNode = 0,		///< Узел, содержащий атрибут. Если передан 0, то атрибут берется у текущего узла
					bool bCreate = true			///< Признак необходимости создания атрибута при его отстутсвии
				);

	/// Удаление атрибута
	/// \return Признак успешного выполнения операции.
	bool DeleteAttr	(
						const QString& strAttrName,	///< Имя удаляемого атрибута.
						xmlNodePtr pNode = 0		///< Узел, содержащий атрибут. Если передан 0, то атрибут удаляется у текущего узла
					);

	/// Получение XPath запроса для поиска узла
	/// \return Строка, содержащая XPath запрос для поиска узла
	QString GetQuery(
						QStringList lstKeys,		///< Наименования ключевых атрибутов
						xmlNodePtr pNode = 0		///< Узел для получения запроса. Если передан 0, запрос формируется для текущего узла
					);

	/// Клонирование узла. Клонированный узел в дальнейшем можно присоединить в другой части документа при помощи функции \ref AddNode
	/// \return Указатель на клонированный узел. Если возвращается 0, то при клонировании возникла ошибка.
	xmlNodePtr Clone(
						xmlNodePtr pNode = 0, ///< Клонируемый узел. Если передан 0, то клонируется текущий узел
						bool bDeep = true	  ///< Признак рекурсивного клонирования, при котором клонируется всё поддерево указанного узла
					);

	/// Получение текущего узла
	/// \return Указатель на текущий узел. Если возвращается 0, то текущий узел не определен.
	xmlNodePtr GetPosition();

	/// Установка текущего узла
	void SetPosition(
						xmlNodePtr pNode = 0	///< Указатель на узел, устанавливаемый в качестве текущего. Если передается 0, то в качестве текущего устанавливается корневой узел
					);

	/// Перемещение к родительскому узлу.
	/// \return Указатель на родительский узел. Если возвращается 0, то при переходе на родительский узел возникла ошибка.
	xmlNodePtr MoveParent();

	/// Проверка наличия дочерних узлов.
	/// \return Признак наличия дочерних узлов.
	bool HasChilds	(
						xmlNodePtr pNode = 0 ///< Проверяемый узел. Если передан 0, то текущий узел проверяется на наличие дочерних узлов.
					);

	/// Перемещение к первому дочернему узлу.
	/// \return Указатель на первый дочерний узел. Если возвращается 0, то дочерних узлов не существует или при переходе возникла ошибка.
	xmlNodePtr MoveFirstChild();

	/// Перемещение к соседнему узлу.
	/// \return Указатель на соседний узел. Если возвращается 0, то такого узла не существует.
	xmlNodePtr MoveNextSibling();

	/// Перемещение к первому узлу, удовлетворяющему XPath запросу.
	/// \return Указатель на узел. Если возвращается 0, то такого узла не существует.
	xmlNodePtr MoveFirst(
							const QString& strXPathQuery, ///< XPath запрос
							xmlNodePtr pParent = 0,		  ///< Узел, в поддереве которого осуществляется поиск. Если передается 0, то поиск осуществляется в поддереве текущего узла
							int* pnCount = 0			  ///< Количество узлов, удовлетворяющих запросу
						);
	/// Перемещение к следующему узлу, удовлетворяющему XPath запросу.
	/// \return Указатель на узел. Если возвращается 0, то такого узла не существует.
	xmlNodePtr MoveNext();

	/// Прямая установка содержимого узла
	/// \return Признак успешности выполнения установки содержимого.
	bool SetContent	(
						const QString& strContent,	///< Содержиоме узла 
						xmlNodePtr pNode = 0		///< Узел, для установки содержимого. Если передан 0, то устанавливается содержимое текущего узла
					);

	/// Получение содержимого узла
	/// \return Содержимое узла.
	QString GetContent	(
							xmlNodePtr pNode = 0		///< Узел, для получения содержимого. Если передан 0, то возвращается содержимое текущего узла
						);

	/// Сохранение узла в стеке.
	/// \return Признак успешного выполнения операции.
	bool Push	(
					xmlNodePtr pNode = 0		///< Сохраняемый узел. Если передан 0, то сохраняется текущий узел
				);
	
	/// Восстановление узла из стека и установка его в качестве текущего.
	/// \return Указатель на восстановленный узел. При пустом стеке возвращается указатель на текущий узел.
	xmlNodePtr Pop();	

	/// Сохранение текущего запроса в стеке.
	/// \return Признак успешного выполнения операции.
	bool PushQuery();

	/// Восстановление запроса из стека. После восстановления возможно возобновление итерации при помощи функции \ref MoveNext
	/// \return Признак успешного выполнения операции.
	bool PopQuery();

private:
	xmlNodePtr GetNode(xmlNodePtr pNode);
	QString PackValue(const QVariant& vtValue);
	QVariant UnpackValue(const QString& strValue);

private:
	xmlDocPtr		m_pXMLDoc;			// XML документ libxml2
	xmlNodePtr		m_pCurNode;			// Текущий узел документа
	xmlNodeSetPtr	m_pCurNodeSet;		// Текущий запрос
	int				m_nCurItem;			// Текущий элемент запроса
	bool			m_bModified;		// Признак наличия изменений документа с момента создания или последнего сохранения
	bool			m_bAutoDestroy;		// Признак автоматического освобождения всех ресурсов, связанных с документом

private:
	struct CNodeSet
	{
		CNodeSet(xmlNodeSetPtr _set, int _cur): set(_set), cur(_cur) {};

		xmlNodeSetPtr set;
		int	cur;
	};

	QList<CNodeSet>		m_lstSets;		// Стек запросов
	QList<xmlNodePtr>	m_lstNodes;		// Стек узлов
};

#endif // _SYSTEMPROM_XML_H
